/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 55 generated on 2012-02-02 17:14:52.854236
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifdef IKFAST_HEADER
#include IKFAST_HEADER
#endif

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IKReal)6.28318530717959)
#define IKPI  ((IKReal)3.14159265358979)
#define IKPI_2  ((IKReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#endif // _MSC_VER

// defined when creating a shared object/dll
#ifdef IKFAST_CLIBRARY
#ifdef _MSC_VER
#define IKFAST_API extern "C" __declspec(dllexport)
#else
#define IKFAST_API extern "C"
#endif
#else
#define IKFAST_API
#endif

// lapack routines
extern "C" {
	void dgetrf_(const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
	void zgetrf_(const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
	void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
	void dgesv_(const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
	void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
	void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi, double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

#ifdef IKFAST_REAL
	typedef IKFAST_REAL IKReal;
#else
	typedef double IKReal;
#endif

	class IKSolution
	{
	public:
		/// Gets a solution given its free parameters
		/// \param pfree The free parameters required, range is in [-pi,pi]
		void GetSolution(IKReal* psolution, const IKReal* pfree) const {
			for (std::size_t i = 0; i < basesol.size(); ++i) {
				if (basesol[i].freeind < 0)
					psolution[i] = basesol[i].foffset;
				else {
					IKFAST_ASSERT(pfree != NULL);
					psolution[i] = pfree[basesol[i].freeind] * basesol[i].fmul + basesol[i].foffset;
					if (psolution[i] > IKPI) {
						psolution[i] -= IK2PI;
					}
					else if (psolution[i] < -IKPI) {
						psolution[i] += IK2PI;
					}
				}
			}
		}

		/// Gets the free parameters the solution requires to be set before a full solution can be returned
		/// \return vector of indices indicating the free parameters
		const std::vector<int>& GetFree() const { return vfree; }

		struct VARIABLE
		{
			VARIABLE() : fmul(0), foffset(0), freeind(-1), maxsolutions(1) {
				indices[0] = indices[1] = -1;
			}
			IKReal fmul, foffset; ///< joint value is fmul*sol[freeind]+foffset
			signed char freeind; ///< if >= 0, mimics another joint
			unsigned char maxsolutions; ///< max possible indices, 0 if controlled by free index or a free joint itself
			unsigned char indices[2]; ///< unique index of the solution used to keep track on what part it came from. sometimes a solution can be repeated for different indices. store at least another repeated root
		};

		std::vector<VARIABLE> basesol;       ///< solution and their offsets if joints are mimiced
		std::vector<int> vfree;

		bool Validate() const {
			for (size_t i = 0; i < basesol.size(); ++i) {
				if (basesol[i].maxsolutions == (unsigned char)-1) {
					return false;
				}
				if (basesol[i].maxsolutions > 0) {
					if (basesol[i].indices[0] >= basesol[i].maxsolutions) {
						return false;
					}
					if (basesol[i].indices[1] != (unsigned char)-1 && basesol[i].indices[1] >= basesol[i].maxsolutions) {
						return false;
					}
				}
			}
			return true;
		}

		void GetSolutionIndices(std::vector<unsigned int>& v) const {
			v.resize(0);
			v.push_back(0);
			for (int i = (int)basesol.size() - 1; i >= 0; --i) {
				if (basesol[i].maxsolutions != (unsigned char)-1 && basesol[i].maxsolutions > 1) {
					for (size_t j = 0; j < v.size(); ++j) {
						v[j] *= basesol[i].maxsolutions;
					}
					size_t orgsize = v.size();
					if (basesol[i].indices[1] != (unsigned char)-1) {
						for (size_t j = 0; j < orgsize; ++j) {
							v.push_back(v[j] + basesol[i].indices[1]);
						}
					}
					if (basesol[i].indices[0] != (unsigned char)-1) {
						for (size_t j = 0; j < orgsize; ++j) {
							v[j] += basesol[i].indices[0];
						}
					}
				}
			}
		}
	};

	inline float IKabs(float f) { return fabsf(f); }
	inline double IKabs(double f) { return fabs(f); }

	inline float IKsqr(float f) { return f*f; }
	inline double IKsqr(double f) { return f*f; }

	inline float IKlog(float f) { return logf(f); }
	inline double IKlog(double f) { return log(f); }

	// allows asin and acos to exceed 1
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IKReal)0.000001)
#endif

	// used to check input to atan2 for degenerate cases
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IKReal)2e-6)
#endif

	// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IKReal)1e-6)
#endif

	inline float IKasin(float f)
	{
		IKFAST_ASSERT(f > -1 - IKFAST_SINCOS_THRESH && f < 1 + IKFAST_SINCOS_THRESH); // any more error implies something is wrong with the solver
		if (f <= -1) return -IKPI_2;
		else if (f >= 1) return IKPI_2;
		return asinf(f);
	}
	inline double IKasin(double f)
	{
		IKFAST_ASSERT(f > -1 - IKFAST_SINCOS_THRESH && f < 1 + IKFAST_SINCOS_THRESH); // any more error implies something is wrong with the solver
		if (f <= -1) return -IKPI_2;
		else if (f >= 1) return IKPI_2;
		return asin(f);
	}

	// return positive value in [0,y)
	inline float IKfmod(float x, float y)
	{
		while (x < 0) {
			x += y;
		}
		return fmodf(x, y);
	}

	// return positive value in [0,y)
	inline float IKfmod(double x, double y)
	{
		while (x < 0) {
			x += y;
		}
		return fmod(x, y);
	}

	inline float IKacos(float f)
	{
		IKFAST_ASSERT(f > -1 - IKFAST_SINCOS_THRESH && f < 1 + IKFAST_SINCOS_THRESH); // any more error implies something is wrong with the solver
		if (f <= -1) return IKPI;
		else if (f >= 1) return 0;
		return acosf(f);
	}
	inline double IKacos(double f)
	{
		IKFAST_ASSERT(f > -1 - IKFAST_SINCOS_THRESH && f < 1 + IKFAST_SINCOS_THRESH); // any more error implies something is wrong with the solver
		if (f <= -1) return IKPI;
		else if (f >= 1) return 0;
		return acos(f);
	}
	inline float IKsin(float f) { return sinf(f); }
	inline double IKsin(double f) { return sin(f); }
	inline float IKcos(float f) { return cosf(f); }
	inline double IKcos(double f) { return cos(f); }
	inline float IKtan(float f) { return tanf(f); }
	inline double IKtan(double f) { return tan(f); }
	inline float IKsqrt(float f) { if (f <= 0.0f) return 0.0f; return sqrtf(f); }
	inline double IKsqrt(double f) { if (f <= 0.0) return 0.0; return sqrt(f); }
	inline float IKatan2(float fy, float fx) {
		if (isnan(fy)) {
			IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
			return IKPI_2;
		}
		else if (isnan(fx)) {
			return 0;
		}
		return atan2f(fy, fx);
	}
	inline double IKatan2(double fy, double fx) {
		if (isnan(fy)) {
			IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
			return IKPI_2;
		}
		else if (isnan(fx)) {
			return 0;
		}
		return atan2(fy, fx);
	}

	inline float IKsign(float f) {
		if (f > 0) {
			return 1.0f;
		}
		else if (f < 0) {
			return -1.0f;
		}
		return 0;
	}

	inline double IKsign(double f) {
		if (f > 0) {
			return 1.0;
		}
		else if (f < 0) {
			return -1.0;
		}
		return 0;
	}

	/// solves the forward kinematics equations.
	/// \param pfree is an array specifying the free joints of the chain.
	IKFAST_API void fk(const IKReal* j, IKReal* eetrans, IKReal* eerot) {
		IKReal x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33, x34, x35, x36, x37, x38, x39, x40, x41, x42, x43, x44, x45, x46, x47, x48, x49, x50, x51, x52, x53, x54, x55, x56, x57, x58, x59, x60, x61, x62, x63, x64, x65, x66, x67, x68, x69, x70, x71, x72, x73, x74, x75, x76, x77, x78, x79, x80, x81, x82, x83, x84, x85, x86, x87, x88, x89, x90, x91, x92, x93, x94, x95, x96, x97, x98, x99;
		x0 = IKcos(j[1]);
		x1 = IKcos(j[2]);
		x2 = IKcos(j[3]);
		x3 = IKsin(j[1]);
		x4 = IKsin(j[3]);
		x5 = IKsin(j[4]);
		x6 = ((x3)*(x4));
		x7 = ((x0)*(x1)*(x2));
		x8 = IKcos(j[4]);
		x9 = IKsin(j[2]);
		x10 = IKsin(j[6]);
		x11 = IKcos(j[6]);
		x12 = IKsin(j[5]);
		x13 = IKcos(j[5]);
		x14 = IKcos(j[0]);
		x15 = ((x0)*(x1)*(x4));
		x16 = ((x2)*(x3));
		x17 = ((x15)+(x16));
		x18 = ((-1.00000000000000)*(x17));
		x19 = ((x12)*(x18));
		x20 = ((x7)+(((-1.00000000000000)*(x6))));
		x21 = ((x20)*(x8));
		x22 = ((x0)*(x5)*(x9));
		x23 = ((((-1.00000000000000)*(x22))) + (x21));
		x24 = ((x13)*(x23));
		x25 = ((x19)+(x24));
		x26 = ((x6)+(((-1.00000000000000)*(x7))));
		x27 = ((x26)*(x5));
		x28 = ((x0)*(x8)*(x9));
		x29 = ((((-1.00000000000000)*(x28))) + (x27));
		x30 = IKsin(j[0]);
		x31 = ((x12)*(x4)*(x9));
		x32 = ((x2)*(x8)*(x9));
		x33 = ((x1)*(x5));
		x34 = ((x33)+(x32));
		x35 = ((-1.00000000000000)*(x34));
		x36 = ((x13)*(x35));
		x37 = ((x31)+(x36));
		x38 = ((x2)*(x5)*(x9));
		x39 = ((x1)*(x8));
		x40 = ((((-1.00000000000000)*(x39))) + (x38));
		x41 = ((x10)*(x40));
		x42 = ((x11)*(x37));
		x43 = ((x42)+(x41));
		x44 = ((x11)*(x25));
		x45 = ((x10)*(x29));
		x46 = ((x44)+(x45));
		x47 = ((-1.00000000000000)*(x37));
		x48 = ((x10)*(x47));
		x49 = ((x11)*(x40));
		x50 = ((x48)+(x49));
		x51 = ((-1.00000000000000)*(x25));
		x52 = ((x10)*(x51));
		x53 = ((x11)*(x29));
		x54 = ((x53)+(x52));
		x55 = ((x12)*(x34));
		x56 = ((x13)*(x4)*(x9));
		x57 = ((x55)+(x56));
		x58 = ((((-1.00000000000000)*(x21))) + (x22));
		x59 = ((x12)*(x58));
		x60 = ((x13)*(x18));
		x61 = ((x59)+(x60));
		x62 = ((0.182500000000000)*(x32));
		x63 = ((0.182500000000000)*(x33));
		x64 = ((x62)+(x63));
		x65 = ((x12)*(x64));
		x66 = ((0.276500000000000)*(x4)*(x9));
		x67 = ((0.182500000000000)*(x56));
		x68 = ((x65)+(x66)+(x67));
		x69 = ((0.182500000000000)*(x22));
		x70 = ((0.182500000000000)*(x21));
		x71 = ((((-1.00000000000000)*(x70))) + (x69));
		x72 = ((x12)*(x71));
		x73 = ((0.182500000000000)*(x15));
		x74 = ((0.182500000000000)*(x16));
		x75 = ((x74)+(x73));
		x76 = ((-1.00000000000000)*(x75));
		x77 = ((x13)*(x76));
		x78 = ((x77)+(x72));
		x79 = ((0.328000000000000)*(x3));
		x80 = ((0.276500000000000)*(x16));
		x81 = ((0.276500000000000)*(x15));
		x82 = ((x79)+(x80)+(x81));
		x83 = ((x78)+(((-1.00000000000000)*(x82))));
		x84 = ((x0)*(x4));
		x85 = ((x1)*(x16));
		x86 = ((x84)+(x85));
		x87 = ((-1.00000000000000)*(x86));
		x88 = ((x5)*(x87));
		x89 = ((x3)*(x8)*(x9));
		x90 = ((x88)+(((-1.00000000000000)*(x89))));
		x91 = ((x0)*(x2));
		x92 = ((x1)*(x6));
		x93 = ((x91)+(((-1.00000000000000)*(x92))));
		x94 = ((x12)*(x93));
		x95 = ((x8)*(x86));
		x96 = ((x3)*(x5)*(x9));
		x97 = ((x95)+(((-1.00000000000000)*(x96))));
		x98 = ((x13)*(x97));
		x99 = ((x98)+(x94));
		eerot[0] = ((((x14)*(x46))) + (((x30)*(x43))));
		eerot[1] = ((((x14)*(x54))) + (((x30)*(x50))));
		eerot[2] = ((((x14)*(x61))) + (((x30)*(x57))));
		eetrans[0] = ((((x14)*(x83))) + (((x30)*(x68))));
		eerot[3] = ((((x30)*(x46))) + (((-1.00000000000000)*(x14)*(x43))));
		eerot[4] = ((((-1.00000000000000)*(x14)*(x50))) + (((x30)*(x54))));
		eerot[5] = ((((-1.00000000000000)*(x14)*(x57))) + (((x30)*(x61))));
		eetrans[1] = ((((x30)*(x83))) + (((-1.00000000000000)*(x14)*(x68))));
		eerot[6] = ((((x10)*(x90))) + (((x11)*(x99))));
		eerot[7] = ((((x11)*(x90))) + (((-1.00000000000000)*(x10)*(x99))));
		eerot[8] = ((((x13)*(x93))) + (((x12)*(((x96)+(((-1.00000000000000)*(x95))))))));
		eetrans[2] = ((0.300000000000000) + (((-0.276500000000000)*(x92))) + (((x12)*(((((0.182500000000000)*(x96))) + (((-0.182500000000000)*(x95))))))) + (((0.328000000000000)*(x0))) + (((x13)*(((((0.182500000000000)*(x91))) + (((-0.182500000000000)*(x92))))))) + (((0.276500000000000)*(x91))));
	}

	IKFAST_API int getNumFreeParameters() { return 1; }
	IKFAST_API int* getFreeParameters() { static int freeparams[] = { 0 }; return freeparams; }
	IKFAST_API int getNumJoints() { return 7; }

	IKFAST_API int getIKRealSize() { return sizeof(IKReal); }

	IKFAST_API int getIKType() { return 0x67000001; }

	class IKSolver {
	public:
		IKReal j1, cj1, sj1, htj1, j2, cj2, sj2, htj2, j3, cj3, sj3, htj3, j4, cj4, sj4, htj4, j5, cj5, sj5, htj5, j6, cj6, sj6, htj6, j0, cj0, sj0, htj0, new_r00, r00, rxp0_0, new_r01, r01, rxp0_1, new_r02, r02, rxp0_2, new_r10, r10, rxp1_0, new_r11, r11, rxp1_1, new_r12, r12, rxp1_2, new_r20, r20, rxp2_0, new_r21, r21, rxp2_1, new_r22, r22, rxp2_2, new_px, px, npx, new_py, py, npy, new_pz, pz, npz, pp;
		unsigned char _ij1[2], _nj1, _ij2[2], _nj2, _ij3[2], _nj3, _ij4[2], _nj4, _ij5[2], _nj5, _ij6[2], _nj6, _ij0[2], _nj0;

		bool ik(const IKReal* eetrans, const IKReal* eerot, const IKReal* pfree, std::vector<IKSolution>& vsolutions) {
			j1 = numeric_limits<IKReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2 = numeric_limits<IKReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j3 = numeric_limits<IKReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4 = numeric_limits<IKReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5 = numeric_limits<IKReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; j6 = numeric_limits<IKReal>::quiet_NaN(); _ij6[0] = -1; _ij6[1] = -1; _nj6 = -1;  _ij0[0] = -1; _ij0[1] = -1; _nj0 = 0;
			for (int dummyiter = 0; dummyiter < 1; ++dummyiter) {
				vsolutions.resize(0); vsolutions.reserve(8);
				j0 = pfree[0]; cj0 = cos(pfree[0]); sj0 = sin(pfree[0]);
				r00 = eerot[0 * 3 + 0];
				r01 = eerot[0 * 3 + 1];
				r02 = eerot[0 * 3 + 2];
				r10 = eerot[1 * 3 + 0];
				r11 = eerot[1 * 3 + 1];
				r12 = eerot[1 * 3 + 2];
				r20 = eerot[2 * 3 + 0];
				r21 = eerot[2 * 3 + 1];
				r22 = eerot[2 * 3 + 2];
				px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

				new_r00 = ((((r00)*(IKcos(j0)))) + (((r10)*(IKsin(j0)))));
				new_r01 = ((((r01)*(IKcos(j0)))) + (((r11)*(IKsin(j0)))));
				new_r02 = ((((r12)*(IKsin(j0)))) + (((r02)*(IKcos(j0)))));
				IKReal x100 = IKcos(j0);
				IKReal x101 = IKsin(j0);
				new_px = ((((py)*(x101))) + (((-0.182500000000000)*(r02)*(x100))) + (((px)*(x100))) + (((-0.182500000000000)*(r12)*(x101))));
				new_r10 = r20;
				new_r11 = r21;
				new_r12 = r22;
				new_py = ((-0.300000000000000) + (((-0.182500000000000)*(r22))) + (pz));
				new_r20 = ((((-1.00000000000000)*(r10)*(IKcos(j0)))) + (((r00)*(IKsin(j0)))));
				new_r21 = ((((r01)*(IKsin(j0)))) + (((-1.00000000000000)*(r11)*(IKcos(j0)))));
				new_r22 = ((((-1.00000000000000)*(r12)*(IKcos(j0)))) + (((r02)*(IKsin(j0)))));
				IKReal x102 = IKsin(j0);
				IKReal x103 = IKcos(j0);
				new_pz = ((((-0.182500000000000)*(r02)*(x102))) + (((px)*(x102))) + (((0.182500000000000)*(r12)*(x103))) + (((-1.00000000000000)*(py)*(x103))));
				r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
				pp = (((px)*(px)) + ((py)*(py)) + ((pz)*(pz)));
				npx = ((((px)*(r00))) + (((py)*(r10))) + (((pz)*(r20))));
				npy = ((((px)*(r01))) + (((py)*(r11))) + (((pz)*(r21))));
				npz = ((((px)*(r02))) + (((py)*(r12))) + (((pz)*(r22))));
				rxp0_0 = ((((-1.00000000000000)*(py)*(r20))) + (((pz)*(r10))));
				rxp0_1 = ((((px)*(r20))) + (((-1.00000000000000)*(pz)*(r00))));
				rxp0_2 = ((((-1.00000000000000)*(px)*(r10))) + (((py)*(r00))));
				rxp1_0 = ((((-1.00000000000000)*(py)*(r21))) + (((pz)*(r11))));
				rxp1_1 = ((((px)*(r21))) + (((-1.00000000000000)*(pz)*(r01))));
				rxp1_2 = ((((-1.00000000000000)*(px)*(r11))) + (((py)*(r01))));
				rxp2_0 = ((((-1.00000000000000)*(py)*(r22))) + (((pz)*(r12))));
				rxp2_1 = ((((px)*(r22))) + (((-1.00000000000000)*(pz)*(r02))));
				rxp2_2 = ((((-1.00000000000000)*(px)*(r12))) + (((py)*(r02))));
				{
					IKReal dummyeval[1];
					dummyeval[0] = (((px)*(px)) + ((py)*(py)));
					if (IKabs(dummyeval[0]) < 0.0000010000000000)
					{
						{
							IKReal dummyeval[1];
							dummyeval[0] = (((px)*(px)) + ((py)*(py)));
							if (IKabs(dummyeval[0]) < 0.0000010000000000)
							{
								continue;

							}
							else
							{
								{
									IKReal j1array[2], cj1array[2], sj1array[2];
									bool j1valid[2] = { false };
									_nj1 = 2;
									IKReal x104 = ((0.656000000000000)*(py));
									IKReal x105 = ((-0.656000000000000)*(px));
									if (IKabs(x104) < IKFAST_ATAN2_MAGTHRESH && IKabs(x105) < IKFAST_ATAN2_MAGTHRESH)
										continue;
									IKReal x106 = IKatan2(x104, x105);
									IKReal x107 = (py)*(py);
									IKReal x108 = ((0.430336000000000)*(x107));
									IKReal x109 = (px)*(px);
									IKReal x110 = ((0.430336000000000)*(x109));
									IKReal x111 = ((x110)+(x108));
									if ((x111) < (IKReal)-0.00001)
										continue;
									IKReal x112 = IKsqrt(x111);
									IKReal x113 = IKabs(x112);
									IKReal x114 = ((IKabs(x113) != 0) ? ((IKReal)1 / (x113)) : (IKReal)1.0e30);
									IKReal x115 = ((0.0311317500000000) + (pp));
									IKReal x116 = ((x114)*(x115));
									if ((x116) < -1 - IKFAST_SINCOS_THRESH || (x116) > 1 + IKFAST_SINCOS_THRESH)
										continue;
									IKReal x117 = IKasin(x116);
									j1array[0] = ((((-1.00000000000000)*(x106))) + (x117));
									sj1array[0] = IKsin(j1array[0]);
									cj1array[0] = IKcos(j1array[0]);
									j1array[1] = ((3.14159265358979) + (((-1.00000000000000)*(x106))) + (((-1.00000000000000)*(x117))));
									sj1array[1] = IKsin(j1array[1]);
									cj1array[1] = IKcos(j1array[1]);
									if (j1array[0] > IKPI)
									{
										j1array[0] -= IK2PI;
									}
									else if (j1array[0] < -IKPI)
									{
										j1array[0] += IK2PI;
									}
									j1valid[0] = true;
									if (j1array[1] > IKPI)
									{
										j1array[1] -= IK2PI;
									}
									else if (j1array[1] < -IKPI)
									{
										j1array[1] += IK2PI;
									}
									j1valid[1] = true;
									for (int ij1 = 0; ij1 < 2; ++ij1)
									{
										if (!j1valid[ij1])
										{
											continue;
										}
										_ij1[0] = ij1; _ij1[1] = -1;
										for (int iij1 = ij1 + 1; iij1 < 2; ++iij1)
										{
											if (j1valid[iij1] && IKabs(cj1array[ij1] - cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1] - sj1array[iij1]) < IKFAST_SOLUTION_THRESH)
											{
												j1valid[iij1] = false; _ij1[1] = iij1; break;
											}
										}
										j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

										{
											IKReal j5array[2], cj5array[2], sj5array[2];
											bool j5valid[2] = { false };
											_nj5 = 2;
											cj5array[0] = ((((-1.18625678119349)*(cj1)*(r12))) + (((1.18625678119349)*(r02)*(sj1))) + (((3.61663652802893)*(npz))));
											if (cj5array[0] >= -1 - IKFAST_SINCOS_THRESH && cj5array[0] <= 1 + IKFAST_SINCOS_THRESH)
											{
												j5valid[0] = j5valid[1] = true;
												j5array[0] = IKacos(cj5array[0]);
												sj5array[0] = IKsin(j5array[0]);
												cj5array[1] = cj5array[0];
												j5array[1] = -j5array[0];
												sj5array[1] = -sj5array[0];
											}
											else if (isnan(cj5array[0]))
											{
												// probably any value will work
												j5valid[0] = true;
												cj5array[0] = 1; sj5array[0] = 0; j5array[0] = 0;
											}
											for (int ij5 = 0; ij5 < 2; ++ij5)
											{
												if (!j5valid[ij5])
												{
													continue;
												}
												_ij5[0] = ij5; _ij5[1] = -1;
												for (int iij5 = ij5 + 1; iij5 < 2; ++iij5)
												{
													if (j5valid[iij5] && IKabs(cj5array[ij5] - cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5] - sj5array[iij5]) < IKFAST_SOLUTION_THRESH)
													{
														j5valid[iij5] = false; _ij5[1] = iij5; break;
													}
												}
												j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

												{
													IKReal dummyeval[1];
													IKReal gconst0;
													gconst0 = IKsign(sj5);
													dummyeval[0] = sj5;
													if (IKabs(dummyeval[0]) < 0.0000010000000000)
													{
														{
															IKReal evalcond[5];
															evalcond[0] = ((-3.14159265358979) + (IKfmod(((3.14159265358979) + (j5)), 6.28318530717959)));
															evalcond[1] = ((-0.0311317500000000) + (((-0.656000000000000)*(px)*(sj1))) + (((-1.00000000000000)*(pp))) + (((0.656000000000000)*(cj1)*(py))));
															evalcond[2] = ((-0.276500000000000) + (((0.328000000000000)*(r02)*(sj1))) + (npz)+(((-0.328000000000000)*(cj1)*(r12))));
															evalcond[3] = ((((0.328000000000000)*(r00)*(sj1))) + (npx)+(((-0.328000000000000)*(cj1)*(r10))));
															evalcond[4] = ((((0.328000000000000)*(r01)*(sj1))) + (npy)+(((-0.328000000000000)*(cj1)*(r11))));
															if (IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000)
															{
																{
																	IKReal j6array[2], cj6array[2], sj6array[2];
																	bool j6valid[2] = { false };
																	_nj6 = 2;
																	IKReal x118 = ((0.328000000000000)*(r00)*(sj1));
																	IKReal x119 = ((npx)+(x118));
																	IKReal x120 = ((0.328000000000000)*(cj1)*(r10));
																	IKReal x121 = ((((-1.00000000000000)*(x120))) + (x119));
																	IKReal x122 = ((0.328000000000000)*(cj1)*(r11));
																	IKReal x123 = ((0.328000000000000)*(r01)*(sj1));
																	IKReal x124 = ((npy)+(x123));
																	IKReal x125 = ((((-1.00000000000000)*(x124))) + (x122));
																	if (IKabs(x121) < IKFAST_ATAN2_MAGTHRESH && IKabs(x125) < IKFAST_ATAN2_MAGTHRESH)
																		continue;
																	IKReal x126 = IKatan2(x121, x125);
																	j6array[0] = ((-1.00000000000000)*(x126));
																	sj6array[0] = IKsin(j6array[0]);
																	cj6array[0] = IKcos(j6array[0]);
																	j6array[1] = ((3.14159265358979) + (((-1.00000000000000)*(x126))));
																	sj6array[1] = IKsin(j6array[1]);
																	cj6array[1] = IKcos(j6array[1]);
																	if (j6array[0] > IKPI)
																	{
																		j6array[0] -= IK2PI;
																	}
																	else if (j6array[0] < -IKPI)
																	{
																		j6array[0] += IK2PI;
																	}
																	j6valid[0] = true;
																	if (j6array[1] > IKPI)
																	{
																		j6array[1] -= IK2PI;
																	}
																	else if (j6array[1] < -IKPI)
																	{
																		j6array[1] += IK2PI;
																	}
																	j6valid[1] = true;
																	for (int ij6 = 0; ij6 < 2; ++ij6)
																	{
																		if (!j6valid[ij6])
																		{
																			continue;
																		}
																		_ij6[0] = ij6; _ij6[1] = -1;
																		for (int iij6 = ij6 + 1; iij6 < 2; ++iij6)
																		{
																			if (j6valid[iij6] && IKabs(cj6array[ij6] - cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6] - sj6array[iij6]) < IKFAST_SOLUTION_THRESH)
																			{
																				j6valid[iij6] = false; _ij6[1] = iij6; break;
																			}
																		}
																		j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
																		{
																			IKReal evalcond[1];
																			IKReal x127 = IKsin(j6);
																			IKReal x128 = IKcos(j6);
																			evalcond[0] = ((((0.328000000000000)*(cj1)*(r10)*(x127))) + (((0.328000000000000)*(cj1)*(r11)*(x128))) + (((-1.00000000000000)*(npy)*(x128))) + (((-1.00000000000000)*(npx)*(x127))) + (((-0.328000000000000)*(r00)*(sj1)*(x127))) + (((-0.328000000000000)*(r01)*(sj1)*(x128))));
																			if (IKabs(evalcond[0]) > 0.000001)
																			{
																				continue;
																			}
																		}

																		rotationfunction0(vsolutions);
																	}
																}

															}
															else
															{
																evalcond[0] = ((-3.14159265358979) + (IKfmod(((1.11022302462516e-16) + (j5)), 6.28318530717959)));
																evalcond[1] = ((-0.0311317500000000) + (((-0.656000000000000)*(px)*(sj1))) + (((-1.00000000000000)*(pp))) + (((0.656000000000000)*(cj1)*(py))));
																evalcond[2] = ((0.276500000000000) + (((0.328000000000000)*(r02)*(sj1))) + (npz)+(((-0.328000000000000)*(cj1)*(r12))));
																evalcond[3] = ((((0.328000000000000)*(r00)*(sj1))) + (npx)+(((-0.328000000000000)*(cj1)*(r10))));
																evalcond[4] = ((((0.328000000000000)*(r01)*(sj1))) + (npy)+(((-0.328000000000000)*(cj1)*(r11))));
																if (IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000)
																{
																	{
																		IKReal j6array[2], cj6array[2], sj6array[2];
																		bool j6valid[2] = { false };
																		_nj6 = 2;
																		IKReal x184 = ((0.328000000000000)*(r00)*(sj1));
																		IKReal x185 = ((npx)+(x184));
																		IKReal x186 = ((0.328000000000000)*(cj1)*(r10));
																		IKReal x187 = ((((-1.00000000000000)*(x186))) + (x185));
																		IKReal x188 = ((0.328000000000000)*(cj1)*(r11));
																		IKReal x189 = ((0.328000000000000)*(r01)*(sj1));
																		IKReal x190 = ((npy)+(x189));
																		IKReal x191 = ((((-1.00000000000000)*(x190))) + (x188));
																		if (IKabs(x187) < IKFAST_ATAN2_MAGTHRESH && IKabs(x191) < IKFAST_ATAN2_MAGTHRESH)
																			continue;
																		IKReal x192 = IKatan2(x187, x191);
																		j6array[0] = ((-1.00000000000000)*(x192));
																		sj6array[0] = IKsin(j6array[0]);
																		cj6array[0] = IKcos(j6array[0]);
																		j6array[1] = ((3.14159265358979) + (((-1.00000000000000)*(x192))));
																		sj6array[1] = IKsin(j6array[1]);
																		cj6array[1] = IKcos(j6array[1]);
																		if (j6array[0] > IKPI)
																		{
																			j6array[0] -= IK2PI;
																		}
																		else if (j6array[0] < -IKPI)
																		{
																			j6array[0] += IK2PI;
																		}
																		j6valid[0] = true;
																		if (j6array[1] > IKPI)
																		{
																			j6array[1] -= IK2PI;
																		}
																		else if (j6array[1] < -IKPI)
																		{
																			j6array[1] += IK2PI;
																		}
																		j6valid[1] = true;
																		for (int ij6 = 0; ij6 < 2; ++ij6)
																		{
																			if (!j6valid[ij6])
																			{
																				continue;
																			}
																			_ij6[0] = ij6; _ij6[1] = -1;
																			for (int iij6 = ij6 + 1; iij6 < 2; ++iij6)
																			{
																				if (j6valid[iij6] && IKabs(cj6array[ij6] - cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6] - sj6array[iij6]) < IKFAST_SOLUTION_THRESH)
																				{
																					j6valid[iij6] = false; _ij6[1] = iij6; break;
																				}
																			}
																			j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
																			{
																				IKReal evalcond[1];
																				IKReal x193 = IKsin(j6);
																				IKReal x194 = IKcos(j6);
																				evalcond[0] = ((((0.328000000000000)*(cj1)*(r10)*(x193))) + (((-0.328000000000000)*(r01)*(sj1)*(x194))) + (((-1.00000000000000)*(npx)*(x193))) + (((-1.00000000000000)*(npy)*(x194))) + (((-0.328000000000000)*(r00)*(sj1)*(x193))) + (((0.328000000000000)*(cj1)*(r11)*(x194))));
																				if (IKabs(evalcond[0]) > 0.000001)
																				{
																					continue;
																				}
																			}

																			rotationfunction0(vsolutions);
																		}
																	}

																}
																else
																{
																	if (1)
																	{
																		continue;

																	}
																	else
																	{
																	}
																}
															}
														}

													}
													else
													{
														{
															IKReal j6array[1], cj6array[1], sj6array[1];
															bool j6valid[1] = { false };
															_nj6 = 1;
															if (IKabs(((gconst0)*(((((656.000000000000)*(cj1)*(r11))) + (((-656.000000000000)*(r01)*(sj1))) + (((-2000.00000000000)*(npy))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((gconst0)*(((((2000.00000000000)*(npx))) + (((-656.000000000000)*(cj1)*(r10))) + (((656.000000000000)*(r00)*(sj1))))))) < IKFAST_ATAN2_MAGTHRESH)
																continue;
															j6array[0] = IKatan2(((gconst0)*(((((656.000000000000)*(cj1)*(r11))) + (((-656.000000000000)*(r01)*(sj1))) + (((-2000.00000000000)*(npy)))))), ((gconst0)*(((((2000.00000000000)*(npx))) + (((-656.000000000000)*(cj1)*(r10))) + (((656.000000000000)*(r00)*(sj1)))))));
															sj6array[0] = IKsin(j6array[0]);
															cj6array[0] = IKcos(j6array[0]);
															if (j6array[0] > IKPI)
															{
																j6array[0] -= IK2PI;
															}
															else if (j6array[0] < -IKPI)
															{
																j6array[0] += IK2PI;
															}
															j6valid[0] = true;
															for (int ij6 = 0; ij6 < 1; ++ij6)
															{
																if (!j6valid[ij6])
																{
																	continue;
																}
																_ij6[0] = ij6; _ij6[1] = -1;
																for (int iij6 = ij6 + 1; iij6 < 1; ++iij6)
																{
																	if (j6valid[iij6] && IKabs(cj6array[ij6] - cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6] - sj6array[iij6]) < IKFAST_SOLUTION_THRESH)
																	{
																		j6valid[iij6] = false; _ij6[1] = iij6; break;
																	}
																}
																j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
																{
																	IKReal evalcond[4];
																	IKReal x195 = IKsin(j6);
																	IKReal x196 = IKcos(j6);
																	evalcond[0] = ((((-0.276500000000000)*(sj5)*(x196))) + (((0.328000000000000)*(r00)*(sj1))) + (npx)+(((-0.328000000000000)*(cj1)*(r10))));
																	evalcond[1] = ((((0.276500000000000)*(sj5)*(x195))) + (((0.328000000000000)*(r01)*(sj1))) + (npy)+(((-0.328000000000000)*(cj1)*(r11))));
																	evalcond[2] = ((((0.328000000000000)*(cj1)*(r10)*(x195))) + (((-0.328000000000000)*(r01)*(sj1)*(x196))) + (((-1.00000000000000)*(npx)*(x195))) + (((-1.00000000000000)*(npy)*(x196))) + (((-0.328000000000000)*(r00)*(sj1)*(x195))) + (((0.328000000000000)*(cj1)*(r11)*(x196))));
																	evalcond[3] = ((((-0.328000000000000)*(cj1)*(r10)*(x196))) + (((-0.276500000000000)*(sj5))) + (((-0.328000000000000)*(r01)*(sj1)*(x195))) + (((-1.00000000000000)*(npy)*(x195))) + (((npx)*(x196))) + (((0.328000000000000)*(r00)*(sj1)*(x196))) + (((0.328000000000000)*(cj1)*(r11)*(x195))));
																	if (IKabs(evalcond[0]) > 0.000001 || IKabs(evalcond[1]) > 0.000001 || IKabs(evalcond[2]) > 0.000001 || IKabs(evalcond[3]) > 0.000001)
																	{
																		continue;
																	}
																}

																rotationfunction0(vsolutions);
															}
														}

													}

												}
											}
										}
									}
								}

							}

						}

					}
					else
					{
						{
							IKReal j1array[2], cj1array[2], sj1array[2];
							bool j1valid[2] = { false };
							_nj1 = 2;
							IKReal x197 = ((0.656000000000000)*(py));
							IKReal x198 = ((-0.656000000000000)*(px));
							if (IKabs(x197) < IKFAST_ATAN2_MAGTHRESH && IKabs(x198) < IKFAST_ATAN2_MAGTHRESH)
								continue;
							IKReal x199 = IKatan2(x197, x198);
							IKReal x200 = (py)*(py);
							IKReal x201 = ((0.430336000000000)*(x200));
							IKReal x202 = (px)*(px);
							IKReal x203 = ((0.430336000000000)*(x202));
							IKReal x204 = ((x203)+(x201));
							if ((x204) < (IKReal)-0.00001)
								continue;
							IKReal x205 = IKsqrt(x204);
							IKReal x206 = IKabs(x205);
							IKReal x207 = ((IKabs(x206) != 0) ? ((IKReal)1 / (x206)) : (IKReal)1.0e30);
							IKReal x208 = ((0.0311317500000000) + (pp));
							IKReal x209 = ((x207)*(x208));
							if ((x209) < -1 - IKFAST_SINCOS_THRESH || (x209) > 1 + IKFAST_SINCOS_THRESH)
								continue;
							IKReal x210 = IKasin(x209);
							j1array[0] = ((((-1.00000000000000)*(x199))) + (x210));
							sj1array[0] = IKsin(j1array[0]);
							cj1array[0] = IKcos(j1array[0]);
							j1array[1] = ((3.14159265358979) + (((-1.00000000000000)*(x199))) + (((-1.00000000000000)*(x210))));
							sj1array[1] = IKsin(j1array[1]);
							cj1array[1] = IKcos(j1array[1]);
							if (j1array[0] > IKPI)
							{
								j1array[0] -= IK2PI;
							}
							else if (j1array[0] < -IKPI)
							{
								j1array[0] += IK2PI;
							}
							j1valid[0] = true;
							if (j1array[1] > IKPI)
							{
								j1array[1] -= IK2PI;
							}
							else if (j1array[1] < -IKPI)
							{
								j1array[1] += IK2PI;
							}
							j1valid[1] = true;
							for (int ij1 = 0; ij1 < 2; ++ij1)
							{
								if (!j1valid[ij1])
								{
									continue;
								}
								_ij1[0] = ij1; _ij1[1] = -1;
								for (int iij1 = ij1 + 1; iij1 < 2; ++iij1)
								{
									if (j1valid[iij1] && IKabs(cj1array[ij1] - cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1] - sj1array[iij1]) < IKFAST_SOLUTION_THRESH)
									{
										j1valid[iij1] = false; _ij1[1] = iij1; break;
									}
								}
								j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

								{
									IKReal j5array[2], cj5array[2], sj5array[2];
									bool j5valid[2] = { false };
									_nj5 = 2;
									cj5array[0] = ((((-1.18625678119349)*(cj1)*(r12))) + (((1.18625678119349)*(r02)*(sj1))) + (((3.61663652802893)*(npz))));
									if (cj5array[0] >= -1 - IKFAST_SINCOS_THRESH && cj5array[0] <= 1 + IKFAST_SINCOS_THRESH)
									{
										j5valid[0] = j5valid[1] = true;
										j5array[0] = IKacos(cj5array[0]);
										sj5array[0] = IKsin(j5array[0]);
										cj5array[1] = cj5array[0];
										j5array[1] = -j5array[0];
										sj5array[1] = -sj5array[0];
									}
									else if (isnan(cj5array[0]))
									{
										// probably any value will work
										j5valid[0] = true;
										cj5array[0] = 1; sj5array[0] = 0; j5array[0] = 0;
									}
									for (int ij5 = 0; ij5 < 2; ++ij5)
									{
										if (!j5valid[ij5])
										{
											continue;
										}
										_ij5[0] = ij5; _ij5[1] = -1;
										for (int iij5 = ij5 + 1; iij5 < 2; ++iij5)
										{
											if (j5valid[iij5] && IKabs(cj5array[ij5] - cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5] - sj5array[iij5]) < IKFAST_SOLUTION_THRESH)
											{
												j5valid[iij5] = false; _ij5[1] = iij5; break;
											}
										}
										j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

										{
											IKReal dummyeval[1];
											IKReal gconst0;
											gconst0 = IKsign(sj5);
											dummyeval[0] = sj5;
											if (IKabs(dummyeval[0]) < 0.0000010000000000)
											{
												{
													IKReal evalcond[5];
													evalcond[0] = ((-3.14159265358979) + (IKfmod(((3.14159265358979) + (j5)), 6.28318530717959)));
													evalcond[1] = ((-0.0311317500000000) + (((-0.656000000000000)*(px)*(sj1))) + (((-1.00000000000000)*(pp))) + (((0.656000000000000)*(cj1)*(py))));
													evalcond[2] = ((-0.276500000000000) + (((0.328000000000000)*(r02)*(sj1))) + (npz)+(((-0.328000000000000)*(cj1)*(r12))));
													evalcond[3] = ((((0.328000000000000)*(r00)*(sj1))) + (npx)+(((-0.328000000000000)*(cj1)*(r10))));
													evalcond[4] = ((((0.328000000000000)*(r01)*(sj1))) + (npy)+(((-0.328000000000000)*(cj1)*(r11))));
													if (IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000)
													{
														{
															IKReal j6array[2], cj6array[2], sj6array[2];
															bool j6valid[2] = { false };
															_nj6 = 2;
															IKReal x211 = ((0.328000000000000)*(r00)*(sj1));
															IKReal x212 = ((npx)+(x211));
															IKReal x213 = ((0.328000000000000)*(cj1)*(r10));
															IKReal x214 = ((x212)+(((-1.00000000000000)*(x213))));
															IKReal x215 = ((0.328000000000000)*(cj1)*(r11));
															IKReal x216 = ((0.328000000000000)*(r01)*(sj1));
															IKReal x217 = ((npy)+(x216));
															IKReal x218 = ((x215)+(((-1.00000000000000)*(x217))));
															if (IKabs(x214) < IKFAST_ATAN2_MAGTHRESH && IKabs(x218) < IKFAST_ATAN2_MAGTHRESH)
																continue;
															IKReal x219 = IKatan2(x214, x218);
															j6array[0] = ((-1.00000000000000)*(x219));
															sj6array[0] = IKsin(j6array[0]);
															cj6array[0] = IKcos(j6array[0]);
															j6array[1] = ((3.14159265358979) + (((-1.00000000000000)*(x219))));
															sj6array[1] = IKsin(j6array[1]);
															cj6array[1] = IKcos(j6array[1]);
															if (j6array[0] > IKPI)
															{
																j6array[0] -= IK2PI;
															}
															else if (j6array[0] < -IKPI)
															{
																j6array[0] += IK2PI;
															}
															j6valid[0] = true;
															if (j6array[1] > IKPI)
															{
																j6array[1] -= IK2PI;
															}
															else if (j6array[1] < -IKPI)
															{
																j6array[1] += IK2PI;
															}
															j6valid[1] = true;
															for (int ij6 = 0; ij6 < 2; ++ij6)
															{
																if (!j6valid[ij6])
																{
																	continue;
																}
																_ij6[0] = ij6; _ij6[1] = -1;
																for (int iij6 = ij6 + 1; iij6 < 2; ++iij6)
																{
																	if (j6valid[iij6] && IKabs(cj6array[ij6] - cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6] - sj6array[iij6]) < IKFAST_SOLUTION_THRESH)
																	{
																		j6valid[iij6] = false; _ij6[1] = iij6; break;
																	}
																}
																j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
																{
																	IKReal evalcond[1];
																	IKReal x220 = IKsin(j6);
																	IKReal x221 = IKcos(j6);
																	evalcond[0] = ((((-1.00000000000000)*(npx)*(x220))) + (((0.328000000000000)*(cj1)*(r11)*(x221))) + (((-0.328000000000000)*(r01)*(sj1)*(x221))) + (((0.328000000000000)*(cj1)*(r10)*(x220))) + (((-0.328000000000000)*(r00)*(sj1)*(x220))) + (((-1.00000000000000)*(npy)*(x221))));
																	if (IKabs(evalcond[0]) > 0.000001)
																	{
																		continue;
																	}
																}

																rotationfunction0(vsolutions);
															}
														}

													}
													else
													{
														evalcond[0] = ((-3.14159265358979) + (IKfmod(((1.11022302462516e-16) + (j5)), 6.28318530717959)));
														evalcond[1] = ((-0.0311317500000000) + (((-0.656000000000000)*(px)*(sj1))) + (((-1.00000000000000)*(pp))) + (((0.656000000000000)*(cj1)*(py))));
														evalcond[2] = ((0.276500000000000) + (((0.328000000000000)*(r02)*(sj1))) + (npz)+(((-0.328000000000000)*(cj1)*(r12))));
														evalcond[3] = ((((0.328000000000000)*(r00)*(sj1))) + (npx)+(((-0.328000000000000)*(cj1)*(r10))));
														evalcond[4] = ((((0.328000000000000)*(r01)*(sj1))) + (npy)+(((-0.328000000000000)*(cj1)*(r11))));
														if (IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000)
														{
															{
																IKReal j6array[2], cj6array[2], sj6array[2];
																bool j6valid[2] = { false };
																_nj6 = 2;
																IKReal x222 = ((0.328000000000000)*(r00)*(sj1));
																IKReal x223 = ((npx)+(x222));
																IKReal x224 = ((0.328000000000000)*(cj1)*(r10));
																IKReal x225 = ((x223)+(((-1.00000000000000)*(x224))));
																IKReal x226 = ((0.328000000000000)*(cj1)*(r11));
																IKReal x227 = ((0.328000000000000)*(r01)*(sj1));
																IKReal x228 = ((npy)+(x227));
																IKReal x229 = ((x226)+(((-1.00000000000000)*(x228))));
																if (IKabs(x225) < IKFAST_ATAN2_MAGTHRESH && IKabs(x229) < IKFAST_ATAN2_MAGTHRESH)
																	continue;
																IKReal x230 = IKatan2(x225, x229);
																j6array[0] = ((-1.00000000000000)*(x230));
																sj6array[0] = IKsin(j6array[0]);
																cj6array[0] = IKcos(j6array[0]);
																j6array[1] = ((3.14159265358979) + (((-1.00000000000000)*(x230))));
																sj6array[1] = IKsin(j6array[1]);
																cj6array[1] = IKcos(j6array[1]);
																if (j6array[0] > IKPI)
																{
																	j6array[0] -= IK2PI;
																}
																else if (j6array[0] < -IKPI)
																{
																	j6array[0] += IK2PI;
																}
																j6valid[0] = true;
																if (j6array[1] > IKPI)
																{
																	j6array[1] -= IK2PI;
																}
																else if (j6array[1] < -IKPI)
																{
																	j6array[1] += IK2PI;
																}
																j6valid[1] = true;
																for (int ij6 = 0; ij6 < 2; ++ij6)
																{
																	if (!j6valid[ij6])
																	{
																		continue;
																	}
																	_ij6[0] = ij6; _ij6[1] = -1;
																	for (int iij6 = ij6 + 1; iij6 < 2; ++iij6)
																	{
																		if (j6valid[iij6] && IKabs(cj6array[ij6] - cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6] - sj6array[iij6]) < IKFAST_SOLUTION_THRESH)
																		{
																			j6valid[iij6] = false; _ij6[1] = iij6; break;
																		}
																	}
																	j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
																	{
																		IKReal evalcond[1];
																		IKReal x231 = IKsin(j6);
																		IKReal x232 = IKcos(j6);
																		evalcond[0] = ((((-0.328000000000000)*(r00)*(sj1)*(x231))) + (((-1.00000000000000)*(npx)*(x231))) + (((-0.328000000000000)*(r01)*(sj1)*(x232))) + (((-1.00000000000000)*(npy)*(x232))) + (((0.328000000000000)*(cj1)*(r10)*(x231))) + (((0.328000000000000)*(cj1)*(r11)*(x232))));
																		if (IKabs(evalcond[0]) > 0.000001)
																		{
																			continue;
																		}
																	}

																	rotationfunction0(vsolutions);
																}
															}

														}
														else
														{
															if (1)
															{
																continue;

															}
															else
															{
															}
														}
													}
												}

											}
											else
											{
												{
													IKReal j6array[1], cj6array[1], sj6array[1];
													bool j6valid[1] = { false };
													_nj6 = 1;
													if (IKabs(((gconst0)*(((((656.000000000000)*(cj1)*(r11))) + (((-656.000000000000)*(r01)*(sj1))) + (((-2000.00000000000)*(npy))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((gconst0)*(((((2000.00000000000)*(npx))) + (((-656.000000000000)*(cj1)*(r10))) + (((656.000000000000)*(r00)*(sj1))))))) < IKFAST_ATAN2_MAGTHRESH)
														continue;
													j6array[0] = IKatan2(((gconst0)*(((((656.000000000000)*(cj1)*(r11))) + (((-656.000000000000)*(r01)*(sj1))) + (((-2000.00000000000)*(npy)))))), ((gconst0)*(((((2000.00000000000)*(npx))) + (((-656.000000000000)*(cj1)*(r10))) + (((656.000000000000)*(r00)*(sj1)))))));
													sj6array[0] = IKsin(j6array[0]);
													cj6array[0] = IKcos(j6array[0]);
													if (j6array[0] > IKPI)
													{
														j6array[0] -= IK2PI;
													}
													else if (j6array[0] < -IKPI)
													{
														j6array[0] += IK2PI;
													}
													j6valid[0] = true;
													for (int ij6 = 0; ij6 < 1; ++ij6)
													{
														if (!j6valid[ij6])
														{
															continue;
														}
														_ij6[0] = ij6; _ij6[1] = -1;
														for (int iij6 = ij6 + 1; iij6 < 1; ++iij6)
														{
															if (j6valid[iij6] && IKabs(cj6array[ij6] - cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6] - sj6array[iij6]) < IKFAST_SOLUTION_THRESH)
															{
																j6valid[iij6] = false; _ij6[1] = iij6; break;
															}
														}
														j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
														{
															IKReal evalcond[4];
															IKReal x233 = IKsin(j6);
															IKReal x234 = IKcos(j6);
															evalcond[0] = ((((0.328000000000000)*(r00)*(sj1))) + (npx)+(((-0.328000000000000)*(cj1)*(r10))) + (((-0.276500000000000)*(sj5)*(x234))));
															evalcond[1] = ((((0.328000000000000)*(r01)*(sj1))) + (npy)+(((-0.328000000000000)*(cj1)*(r11))) + (((0.276500000000000)*(sj5)*(x233))));
															evalcond[2] = ((((-0.328000000000000)*(r00)*(sj1)*(x233))) + (((-1.00000000000000)*(npx)*(x233))) + (((-0.328000000000000)*(r01)*(sj1)*(x234))) + (((-1.00000000000000)*(npy)*(x234))) + (((0.328000000000000)*(cj1)*(r10)*(x233))) + (((0.328000000000000)*(cj1)*(r11)*(x234))));
															evalcond[3] = ((((-0.276500000000000)*(sj5))) + (((-0.328000000000000)*(r01)*(sj1)*(x233))) + (((-1.00000000000000)*(npy)*(x233))) + (((-0.328000000000000)*(cj1)*(r10)*(x234))) + (((0.328000000000000)*(r00)*(sj1)*(x234))) + (((0.328000000000000)*(cj1)*(r11)*(x233))) + (((npx)*(x234))));
															if (IKabs(evalcond[0]) > 0.000001 || IKabs(evalcond[1]) > 0.000001 || IKabs(evalcond[2]) > 0.000001 || IKabs(evalcond[3]) > 0.000001)
															{
																continue;
															}
														}

														rotationfunction0(vsolutions);
													}
												}

											}

										}
									}
								}
							}
						}

					}

				}
			}
			return vsolutions.size() > 0;
		}
		inline void rotationfunction0(std::vector<IKSolution>& vsolutions) {
			for (int rotationiter = 0; rotationiter < 1; ++rotationiter) {
				IKReal x129 = ((cj5)*(cj6)*(r10));
				IKReal x130 = ((cj5)*(r11)*(sj6));
				IKReal x131 = ((r12)*(sj5));
				IKReal x132 = ((x131)+(x130));
				IKReal x133 = ((x129)+(((-1.00000000000000)*(x132))));
				IKReal x134 = ((cj5)*(cj6)*(r00));
				IKReal x135 = ((cj5)*(r01)*(sj6));
				IKReal x136 = ((r02)*(sj5));
				IKReal x137 = ((x135)+(x136));
				IKReal x138 = ((x134)+(((-1.00000000000000)*(x137))));
				IKReal x139 = ((r10)*(sj6));
				IKReal x140 = ((cj6)*(r11));
				IKReal x141 = ((x140)+(x139));
				IKReal x142 = ((r00)*(sj6));
				IKReal x143 = ((cj6)*(r01));
				IKReal x144 = ((x142)+(x143));
				IKReal x145 = ((cj5)*(r12));
				IKReal x146 = ((cj6)*(r10)*(sj5));
				IKReal x147 = ((x145)+(x146));
				IKReal x148 = ((r11)*(sj5)*(sj6));
				IKReal x149 = ((((-1.00000000000000)*(x148))) + (x147));
				IKReal x150 = ((cj6)*(r00)*(sj5));
				IKReal x151 = ((cj5)*(r02));
				IKReal x152 = ((x151)+(x150));
				IKReal x153 = ((r01)*(sj5)*(sj6));
				IKReal x154 = ((((-1.00000000000000)*(x153))) + (x152));
				new_r00 = ((((sj1)*(x133))) + (((cj1)*(x138))));
				new_r01 = ((((cj5)*(r21)*(sj6))) + (((r22)*(sj5))) + (((-1.00000000000000)*(cj5)*(cj6)*(r20))));
				new_r02 = ((((-1.00000000000000)*(sj1)*(x138))) + (((cj1)*(x133))));
				new_r10 = ((((sj1)*(x141))) + (((cj1)*(x144))));
				new_r11 = ((((-1.00000000000000)*(r20)*(sj6))) + (((-1.00000000000000)*(cj6)*(r21))));
				new_r12 = ((((-1.00000000000000)*(sj1)*(x144))) + (((cj1)*(x141))));
				new_r20 = ((((sj1)*(x149))) + (((cj1)*(x154))));
				new_r21 = ((((r21)*(sj5)*(sj6))) + (((-1.00000000000000)*(cj6)*(r20)*(sj5))) + (((-1.00000000000000)*(cj5)*(r22))));
				new_r22 = ((((-1.00000000000000)*(sj1)*(x154))) + (((cj1)*(x149))));
				{
					IKReal j3array[2], cj3array[2], sj3array[2];
					bool j3valid[2] = { false };
					_nj3 = 2;
					cj3array[0] = new_r22;
					if (cj3array[0] >= -1 - IKFAST_SINCOS_THRESH && cj3array[0] <= 1 + IKFAST_SINCOS_THRESH)
					{
						j3valid[0] = j3valid[1] = true;
						j3array[0] = IKacos(cj3array[0]);
						sj3array[0] = IKsin(j3array[0]);
						cj3array[1] = cj3array[0];
						j3array[1] = -j3array[0];
						sj3array[1] = -sj3array[0];
					}
					else if (isnan(cj3array[0]))
					{
						// probably any value will work
						j3valid[0] = true;
						cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
					}
					for (int ij3 = 0; ij3 < 2; ++ij3)
					{
						if (!j3valid[ij3])
						{
							continue;
						}
						_ij3[0] = ij3; _ij3[1] = -1;
						for (int iij3 = ij3 + 1; iij3 < 2; ++iij3)
						{
							if (j3valid[iij3] && IKabs(cj3array[ij3] - cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3] - sj3array[iij3]) < IKFAST_SOLUTION_THRESH)
							{
								j3valid[iij3] = false; _ij3[1] = iij3; break;
							}
						}
						j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

						{
							IKReal dummyeval[1];
							IKReal gconst1;
							gconst1 = IKsign(sj3);
							dummyeval[0] = sj3;
							if (IKabs(dummyeval[0]) < 0.0000010000000000)
							{
								{
									IKReal dummyeval[1];
									IKReal gconst2;
									gconst2 = IKsign(((((-1.00000000000000)*((new_r02)*(new_r02)))) + (((-1.00000000000000)*((new_r12)*(new_r12))))));
									dummyeval[0] = ((((-1.00000000000000)*((new_r02)*(new_r02)))) + (((-1.00000000000000)*((new_r12)*(new_r12)))));
									if (IKabs(dummyeval[0]) < 0.0000010000000000)
									{
										{
											IKReal evalcond[7];
											IKReal x155 = ((-1.00000000000000) + (new_r22));
											evalcond[0] = ((-3.14159265358979) + (IKfmod(((3.14159265358979) + (j3)), 6.28318530717959)));
											evalcond[1] = x155;
											evalcond[2] = new_r20;
											evalcond[3] = new_r21;
											evalcond[4] = new_r20;
											evalcond[5] = new_r21;
											evalcond[6] = x155;
											if (IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000)
											{
												{
													IKReal j4array[2], cj4array[2], sj4array[2];
													bool j4valid[2] = { false };
													_nj4 = 2;
													if (IKabs(new_r12) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r02) < IKFAST_ATAN2_MAGTHRESH)
														continue;
													IKReal x156 = IKatan2(new_r12, new_r02);
													j4array[0] = ((-1.00000000000000)*(x156));
													sj4array[0] = IKsin(j4array[0]);
													cj4array[0] = IKcos(j4array[0]);
													j4array[1] = ((3.14159265358979) + (((-1.00000000000000)*(x156))));
													sj4array[1] = IKsin(j4array[1]);
													cj4array[1] = IKcos(j4array[1]);
													if (j4array[0] > IKPI)
													{
														j4array[0] -= IK2PI;
													}
													else if (j4array[0] < -IKPI)
													{
														j4array[0] += IK2PI;
													}
													j4valid[0] = true;
													if (j4array[1] > IKPI)
													{
														j4array[1] -= IK2PI;
													}
													else if (j4array[1] < -IKPI)
													{
														j4array[1] += IK2PI;
													}
													j4valid[1] = true;
													for (int ij4 = 0; ij4 < 2; ++ij4)
													{
														if (!j4valid[ij4])
														{
															continue;
														}
														_ij4[0] = ij4; _ij4[1] = -1;
														for (int iij4 = ij4 + 1; iij4 < 2; ++iij4)
														{
															if (j4valid[iij4] && IKabs(cj4array[ij4] - cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4] - sj4array[iij4]) < IKFAST_SOLUTION_THRESH)
															{
																j4valid[iij4] = false; _ij4[1] = iij4; break;
															}
														}
														j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
														{
															IKReal evalcond[1];
															evalcond[0] = ((((new_r02)*(IKcos(j4)))) + (((-1.00000000000000)*(new_r12)*(IKsin(j4)))));
															if (IKabs(evalcond[0]) > 0.000001)
															{
																continue;
															}
														}

														{
															IKReal j2array[1], cj2array[1], sj2array[1];
															bool j2valid[1] = { false };
															_nj2 = 1;
															if (IKabs(((((-1.00000000000000)*(new_r00)*(sj4))) + (((-1.00000000000000)*(cj4)*(new_r10))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((cj4)*(new_r11))) + (((new_r01)*(sj4))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.00000000000000)*(new_r00)*(sj4))) + (((-1.00000000000000)*(cj4)*(new_r10))))) + IKsqr(((((cj4)*(new_r11))) + (((new_r01)*(sj4))))) - 1) <= IKFAST_SINCOS_THRESH)
																continue;
															j2array[0] = IKatan2(((((-1.00000000000000)*(new_r00)*(sj4))) + (((-1.00000000000000)*(cj4)*(new_r10)))), ((((cj4)*(new_r11))) + (((new_r01)*(sj4)))));
															sj2array[0] = IKsin(j2array[0]);
															cj2array[0] = IKcos(j2array[0]);
															if (j2array[0] > IKPI)
															{
																j2array[0] -= IK2PI;
															}
															else if (j2array[0] < -IKPI)
															{
																j2array[0] += IK2PI;
															}
															j2valid[0] = true;
															for (int ij2 = 0; ij2 < 1; ++ij2)
															{
																if (!j2valid[ij2])
																{
																	continue;
																}
																_ij2[0] = ij2; _ij2[1] = -1;
																for (int iij2 = ij2 + 1; iij2 < 1; ++iij2)
																{
																	if (j2valid[iij2] && IKabs(cj2array[ij2] - cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2] - sj2array[iij2]) < IKFAST_SOLUTION_THRESH)
																	{
																		j2valid[iij2] = false; _ij2[1] = iij2; break;
																	}
																}
																j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
																{
																	IKReal evalcond[4];
																	IKReal x157 = IKcos(j2);
																	IKReal x158 = IKsin(j2);
																	evalcond[0] = ((((cj4)*(new_r10))) + (((new_r00)*(sj4))) + (x158));
																	evalcond[1] = ((((-1.00000000000000)*(x157))) + (((cj4)*(new_r11))) + (((new_r01)*(sj4))));
																	evalcond[2] = ((((-1.00000000000000)*(x157))) + (((cj4)*(new_r00))) + (((-1.00000000000000)*(new_r10)*(sj4))));
																	evalcond[3] = ((((-1.00000000000000)*(x158))) + (((cj4)*(new_r01))) + (((-1.00000000000000)*(new_r11)*(sj4))));
																	if (IKabs(evalcond[0]) > 0.000001 || IKabs(evalcond[1]) > 0.000001 || IKabs(evalcond[2]) > 0.000001 || IKabs(evalcond[3]) > 0.000001)
																	{
																		continue;
																	}
																}

																{
																	vsolutions.push_back(IKSolution()); IKSolution& solution = vsolutions.back();
																	solution.basesol.resize(7);
																	solution.basesol[0].foffset = j0;
																	solution.basesol[0].indices[0] = _ij0[0];
																	solution.basesol[0].indices[1] = _ij0[1];
																	solution.basesol[0].maxsolutions = _nj0;
																	solution.basesol[1].foffset = j1;
																	solution.basesol[1].indices[0] = _ij1[0];
																	solution.basesol[1].indices[1] = _ij1[1];
																	solution.basesol[1].maxsolutions = _nj1;
																	solution.basesol[2].foffset = j2;
																	solution.basesol[2].indices[0] = _ij2[0];
																	solution.basesol[2].indices[1] = _ij2[1];
																	solution.basesol[2].maxsolutions = _nj2;
																	solution.basesol[3].foffset = j3;
																	solution.basesol[3].indices[0] = _ij3[0];
																	solution.basesol[3].indices[1] = _ij3[1];
																	solution.basesol[3].maxsolutions = _nj3;
																	solution.basesol[4].foffset = j4;
																	solution.basesol[4].indices[0] = _ij4[0];
																	solution.basesol[4].indices[1] = _ij4[1];
																	solution.basesol[4].maxsolutions = _nj4;
																	solution.basesol[5].foffset = j5;
																	solution.basesol[5].indices[0] = _ij5[0];
																	solution.basesol[5].indices[1] = _ij5[1];
																	solution.basesol[5].maxsolutions = _nj5;
																	solution.basesol[6].foffset = j6;
																	solution.basesol[6].indices[0] = _ij6[0];
																	solution.basesol[6].indices[1] = _ij6[1];
																	solution.basesol[6].maxsolutions = _nj6;
																	solution.vfree.resize(0);
																}
															}
														}
													}
												}

											}
											else
											{
												evalcond[0] = ((-3.14159265358979) + (IKfmod(((1.11022302462516e-16) + (j3)), 6.28318530717959)));
												evalcond[1] = ((1.00000000000000) + (new_r22));
												evalcond[2] = new_r20;
												evalcond[3] = new_r21;
												evalcond[4] = ((-1.00000000000000)*(new_r20));
												evalcond[5] = ((-1.00000000000000)*(new_r21));
												evalcond[6] = ((-1.00000000000000) + (((-1.00000000000000)*(new_r22))));
												if (IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000)
												{
													{
														IKReal j4array[2], cj4array[2], sj4array[2];
														bool j4valid[2] = { false };
														_nj4 = 2;
														if (IKabs(new_r12) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r02) < IKFAST_ATAN2_MAGTHRESH)
															continue;
														IKReal x159 = IKatan2(new_r12, new_r02);
														j4array[0] = ((-1.00000000000000)*(x159));
														sj4array[0] = IKsin(j4array[0]);
														cj4array[0] = IKcos(j4array[0]);
														j4array[1] = ((3.14159265358979) + (((-1.00000000000000)*(x159))));
														sj4array[1] = IKsin(j4array[1]);
														cj4array[1] = IKcos(j4array[1]);
														if (j4array[0] > IKPI)
														{
															j4array[0] -= IK2PI;
														}
														else if (j4array[0] < -IKPI)
														{
															j4array[0] += IK2PI;
														}
														j4valid[0] = true;
														if (j4array[1] > IKPI)
														{
															j4array[1] -= IK2PI;
														}
														else if (j4array[1] < -IKPI)
														{
															j4array[1] += IK2PI;
														}
														j4valid[1] = true;
														for (int ij4 = 0; ij4 < 2; ++ij4)
														{
															if (!j4valid[ij4])
															{
																continue;
															}
															_ij4[0] = ij4; _ij4[1] = -1;
															for (int iij4 = ij4 + 1; iij4 < 2; ++iij4)
															{
																if (j4valid[iij4] && IKabs(cj4array[ij4] - cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4] - sj4array[iij4]) < IKFAST_SOLUTION_THRESH)
																{
																	j4valid[iij4] = false; _ij4[1] = iij4; break;
																}
															}
															j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
															{
																IKReal evalcond[1];
																evalcond[0] = ((((new_r02)*(IKcos(j4)))) + (((-1.00000000000000)*(new_r12)*(IKsin(j4)))));
																if (IKabs(evalcond[0]) > 0.000001)
																{
																	continue;
																}
															}

															{
																IKReal j2array[1], cj2array[1], sj2array[1];
																bool j2valid[1] = { false };
																_nj2 = 1;
																if (IKabs(((((-1.00000000000000)*(new_r00)*(sj4))) + (((-1.00000000000000)*(cj4)*(new_r10))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((new_r10)*(sj4))) + (((-1.00000000000000)*(cj4)*(new_r00))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.00000000000000)*(new_r00)*(sj4))) + (((-1.00000000000000)*(cj4)*(new_r10))))) + IKsqr(((((new_r10)*(sj4))) + (((-1.00000000000000)*(cj4)*(new_r00))))) - 1) <= IKFAST_SINCOS_THRESH)
																	continue;
																j2array[0] = IKatan2(((((-1.00000000000000)*(new_r00)*(sj4))) + (((-1.00000000000000)*(cj4)*(new_r10)))), ((((new_r10)*(sj4))) + (((-1.00000000000000)*(cj4)*(new_r00)))));
																sj2array[0] = IKsin(j2array[0]);
																cj2array[0] = IKcos(j2array[0]);
																if (j2array[0] > IKPI)
																{
																	j2array[0] -= IK2PI;
																}
																else if (j2array[0] < -IKPI)
																{
																	j2array[0] += IK2PI;
																}
																j2valid[0] = true;
																for (int ij2 = 0; ij2 < 1; ++ij2)
																{
																	if (!j2valid[ij2])
																	{
																		continue;
																	}
																	_ij2[0] = ij2; _ij2[1] = -1;
																	for (int iij2 = ij2 + 1; iij2 < 1; ++iij2)
																	{
																		if (j2valid[iij2] && IKabs(cj2array[ij2] - cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2] - sj2array[iij2]) < IKFAST_SOLUTION_THRESH)
																		{
																			j2valid[iij2] = false; _ij2[1] = iij2; break;
																		}
																	}
																	j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
																	{
																		IKReal evalcond[4];
																		IKReal x160 = IKcos(j2);
																		IKReal x161 = IKsin(j2);
																		evalcond[0] = ((((cj4)*(new_r10))) + (((new_r00)*(sj4))) + (x161));
																		evalcond[1] = ((((-1.00000000000000)*(x160))) + (((cj4)*(new_r11))) + (((new_r01)*(sj4))));
																		evalcond[2] = ((((cj4)*(new_r00))) + (x160)+(((-1.00000000000000)*(new_r10)*(sj4))));
																		evalcond[3] = ((((cj4)*(new_r01))) + (x161)+(((-1.00000000000000)*(new_r11)*(sj4))));
																		if (IKabs(evalcond[0]) > 0.000001 || IKabs(evalcond[1]) > 0.000001 || IKabs(evalcond[2]) > 0.000001 || IKabs(evalcond[3]) > 0.000001)
																		{
																			continue;
																		}
																	}

																	{
																		vsolutions.push_back(IKSolution()); IKSolution& solution = vsolutions.back();
																		solution.basesol.resize(7);
																		solution.basesol[0].foffset = j0;
																		solution.basesol[0].indices[0] = _ij0[0];
																		solution.basesol[0].indices[1] = _ij0[1];
																		solution.basesol[0].maxsolutions = _nj0;
																		solution.basesol[1].foffset = j1;
																		solution.basesol[1].indices[0] = _ij1[0];
																		solution.basesol[1].indices[1] = _ij1[1];
																		solution.basesol[1].maxsolutions = _nj1;
																		solution.basesol[2].foffset = j2;
																		solution.basesol[2].indices[0] = _ij2[0];
																		solution.basesol[2].indices[1] = _ij2[1];
																		solution.basesol[2].maxsolutions = _nj2;
																		solution.basesol[3].foffset = j3;
																		solution.basesol[3].indices[0] = _ij3[0];
																		solution.basesol[3].indices[1] = _ij3[1];
																		solution.basesol[3].maxsolutions = _nj3;
																		solution.basesol[4].foffset = j4;
																		solution.basesol[4].indices[0] = _ij4[0];
																		solution.basesol[4].indices[1] = _ij4[1];
																		solution.basesol[4].maxsolutions = _nj4;
																		solution.basesol[5].foffset = j5;
																		solution.basesol[5].indices[0] = _ij5[0];
																		solution.basesol[5].indices[1] = _ij5[1];
																		solution.basesol[5].maxsolutions = _nj5;
																		solution.basesol[6].foffset = j6;
																		solution.basesol[6].indices[0] = _ij6[0];
																		solution.basesol[6].indices[1] = _ij6[1];
																		solution.basesol[6].maxsolutions = _nj6;
																		solution.vfree.resize(0);
																	}
																}
															}
														}
													}

												}
												else
												{
													if (1)
													{
														continue;

													}
													else
													{
													}
												}
											}
										}

									}
									else
									{
										{
											IKReal j4array[1], cj4array[1], sj4array[1];
											bool j4valid[1] = { false };
											_nj4 = 1;
											if (IKabs(((gconst2)*(new_r12)*(sj3))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.00000000000000)*(gconst2)*(new_r02)*(sj3))) < IKFAST_ATAN2_MAGTHRESH)
												continue;
											j4array[0] = IKatan2(((gconst2)*(new_r12)*(sj3)), ((-1.00000000000000)*(gconst2)*(new_r02)*(sj3)));
											sj4array[0] = IKsin(j4array[0]);
											cj4array[0] = IKcos(j4array[0]);
											if (j4array[0] > IKPI)
											{
												j4array[0] -= IK2PI;
											}
											else if (j4array[0] < -IKPI)
											{
												j4array[0] += IK2PI;
											}
											j4valid[0] = true;
											for (int ij4 = 0; ij4 < 1; ++ij4)
											{
												if (!j4valid[ij4])
												{
													continue;
												}
												_ij4[0] = ij4; _ij4[1] = -1;
												for (int iij4 = ij4 + 1; iij4 < 1; ++iij4)
												{
													if (j4valid[iij4] && IKabs(cj4array[ij4] - cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4] - sj4array[iij4]) < IKFAST_SOLUTION_THRESH)
													{
														j4valid[iij4] = false; _ij4[1] = iij4; break;
													}
												}
												j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
												{
													IKReal evalcond[6];
													IKReal x162 = IKcos(j4);
													IKReal x163 = IKsin(j4);
													evalcond[0] = ((((new_r12)*(x162))) + (((new_r02)*(x163))));
													evalcond[1] = ((((-1.00000000000000)*(new_r12)*(x163))) + (((-1.00000000000000)*(sj3))) + (((new_r02)*(x162))));
													evalcond[2] = ((((-1.00000000000000)*(new_r10)*(sj3)*(x163))) + (((new_r00)*(sj3)*(x162))) + (((cj3)*(new_r20))));
													evalcond[3] = ((((-1.00000000000000)*(new_r11)*(sj3)*(x163))) + (((new_r01)*(sj3)*(x162))) + (((cj3)*(new_r21))));
													evalcond[4] = ((((cj3)*(new_r02)*(x162))) + (((-1.00000000000000)*(new_r22)*(sj3))) + (((-1.00000000000000)*(cj3)*(new_r12)*(x163))));
													evalcond[5] = ((-1.00000000000000) + (((new_r02)*(sj3)*(x162))) + (((-1.00000000000000)*(new_r12)*(sj3)*(x163))) + (((cj3)*(new_r22))));
													if (IKabs(evalcond[0]) > 0.000001 || IKabs(evalcond[1]) > 0.000001 || IKabs(evalcond[2]) > 0.000001 || IKabs(evalcond[3]) > 0.000001 || IKabs(evalcond[4]) > 0.000001 || IKabs(evalcond[5]) > 0.000001)
													{
														continue;
													}
												}

												{
													IKReal dummyeval[1];
													IKReal gconst3;
													gconst3 = IKsign(sj3);
													dummyeval[0] = sj3;
													if (IKabs(dummyeval[0]) < 0.0000010000000000)
													{
														{
															IKReal evalcond[11];
															IKReal x164 = ((new_r02)*(sj4));
															IKReal x165 = ((cj4)*(new_r12));
															IKReal x166 = ((x164)+(x165));
															IKReal x167 = ((cj4)*(new_r02));
															IKReal x168 = ((new_r12)*(sj4));
															IKReal x169 = ((((-1.00000000000000)*(x168))) + (x167));
															IKReal x170 = ((-1.00000000000000) + (new_r22));
															evalcond[0] = ((-3.14159265358979) + (IKfmod(((3.14159265358979) + (j3)), 6.28318530717959)));
															evalcond[1] = x170;
															evalcond[2] = new_r20;
															evalcond[3] = new_r21;
															evalcond[4] = x166;
															evalcond[5] = ((-1.00000000000000)*(x166));
															evalcond[6] = x169;
															evalcond[7] = new_r20;
															evalcond[8] = new_r21;
															evalcond[9] = x169;
															evalcond[10] = x170;
															if (IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000)
															{
																{
																	IKReal j2array[1], cj2array[1], sj2array[1];
																	bool j2valid[1] = { false };
																	_nj2 = 1;
																	if (IKabs(((((-1.00000000000000)*(new_r00)*(sj4))) + (((-1.00000000000000)*(cj4)*(new_r10))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((cj4)*(new_r11))) + (((new_r01)*(sj4))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.00000000000000)*(new_r00)*(sj4))) + (((-1.00000000000000)*(cj4)*(new_r10))))) + IKsqr(((((cj4)*(new_r11))) + (((new_r01)*(sj4))))) - 1) <= IKFAST_SINCOS_THRESH)
																		continue;
																	j2array[0] = IKatan2(((((-1.00000000000000)*(new_r00)*(sj4))) + (((-1.00000000000000)*(cj4)*(new_r10)))), ((((cj4)*(new_r11))) + (((new_r01)*(sj4)))));
																	sj2array[0] = IKsin(j2array[0]);
																	cj2array[0] = IKcos(j2array[0]);
																	if (j2array[0] > IKPI)
																	{
																		j2array[0] -= IK2PI;
																	}
																	else if (j2array[0] < -IKPI)
																	{
																		j2array[0] += IK2PI;
																	}
																	j2valid[0] = true;
																	for (int ij2 = 0; ij2 < 1; ++ij2)
																	{
																		if (!j2valid[ij2])
																		{
																			continue;
																		}
																		_ij2[0] = ij2; _ij2[1] = -1;
																		for (int iij2 = ij2 + 1; iij2 < 1; ++iij2)
																		{
																			if (j2valid[iij2] && IKabs(cj2array[ij2] - cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2] - sj2array[iij2]) < IKFAST_SOLUTION_THRESH)
																			{
																				j2valid[iij2] = false; _ij2[1] = iij2; break;
																			}
																		}
																		j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
																		{
																			IKReal evalcond[4];
																			IKReal x171 = IKcos(j2);
																			IKReal x172 = IKsin(j2);
																			evalcond[0] = ((((cj4)*(new_r10))) + (((new_r00)*(sj4))) + (x172));
																			evalcond[1] = ((((-1.00000000000000)*(x171))) + (((cj4)*(new_r11))) + (((new_r01)*(sj4))));
																			evalcond[2] = ((((cj4)*(new_r00))) + (((-1.00000000000000)*(x171))) + (((-1.00000000000000)*(new_r10)*(sj4))));
																			evalcond[3] = ((((cj4)*(new_r01))) + (((-1.00000000000000)*(x172))) + (((-1.00000000000000)*(new_r11)*(sj4))));
																			if (IKabs(evalcond[0]) > 0.000001 || IKabs(evalcond[1]) > 0.000001 || IKabs(evalcond[2]) > 0.000001 || IKabs(evalcond[3]) > 0.000001)
																			{
																				continue;
																			}
																		}

																		{
																			vsolutions.push_back(IKSolution()); IKSolution& solution = vsolutions.back();
																			solution.basesol.resize(7);
																			solution.basesol[0].foffset = j0;
																			solution.basesol[0].indices[0] = _ij0[0];
																			solution.basesol[0].indices[1] = _ij0[1];
																			solution.basesol[0].maxsolutions = _nj0;
																			solution.basesol[1].foffset = j1;
																			solution.basesol[1].indices[0] = _ij1[0];
																			solution.basesol[1].indices[1] = _ij1[1];
																			solution.basesol[1].maxsolutions = _nj1;
																			solution.basesol[2].foffset = j2;
																			solution.basesol[2].indices[0] = _ij2[0];
																			solution.basesol[2].indices[1] = _ij2[1];
																			solution.basesol[2].maxsolutions = _nj2;
																			solution.basesol[3].foffset = j3;
																			solution.basesol[3].indices[0] = _ij3[0];
																			solution.basesol[3].indices[1] = _ij3[1];
																			solution.basesol[3].maxsolutions = _nj3;
																			solution.basesol[4].foffset = j4;
																			solution.basesol[4].indices[0] = _ij4[0];
																			solution.basesol[4].indices[1] = _ij4[1];
																			solution.basesol[4].maxsolutions = _nj4;
																			solution.basesol[5].foffset = j5;
																			solution.basesol[5].indices[0] = _ij5[0];
																			solution.basesol[5].indices[1] = _ij5[1];
																			solution.basesol[5].maxsolutions = _nj5;
																			solution.basesol[6].foffset = j6;
																			solution.basesol[6].indices[0] = _ij6[0];
																			solution.basesol[6].indices[1] = _ij6[1];
																			solution.basesol[6].maxsolutions = _nj6;
																			solution.vfree.resize(0);
																		}
																	}
																}

															}
															else
															{
																IKReal x173 = ((new_r02)*(sj4));
																IKReal x174 = ((cj4)*(new_r12));
																IKReal x175 = ((x173)+(x174));
																IKReal x176 = ((new_r12)*(sj4));
																IKReal x177 = ((cj4)*(new_r02));
																evalcond[0] = ((-3.14159265358979) + (IKfmod(((1.11022302462516e-16) + (j3)), 6.28318530717959)));
																evalcond[1] = ((1.00000000000000) + (new_r22));
																evalcond[2] = new_r20;
																evalcond[3] = new_r21;
																evalcond[4] = x175;
																evalcond[5] = ((-1.00000000000000)*(x175));
																evalcond[6] = ((((-1.00000000000000)*(x176))) + (x177));
																evalcond[7] = ((-1.00000000000000)*(new_r20));
																evalcond[8] = ((-1.00000000000000)*(new_r21));
																evalcond[9] = ((((-1.00000000000000)*(x177))) + (x176));
																evalcond[10] = ((-1.00000000000000) + (((-1.00000000000000)*(new_r22))));
																if (IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000)
																{
																	{
																		IKReal j2array[1], cj2array[1], sj2array[1];
																		bool j2valid[1] = { false };
																		_nj2 = 1;
																		if (IKabs(((((-1.00000000000000)*(new_r00)*(sj4))) + (((-1.00000000000000)*(cj4)*(new_r10))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((new_r10)*(sj4))) + (((-1.00000000000000)*(cj4)*(new_r00))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.00000000000000)*(new_r00)*(sj4))) + (((-1.00000000000000)*(cj4)*(new_r10))))) + IKsqr(((((new_r10)*(sj4))) + (((-1.00000000000000)*(cj4)*(new_r00))))) - 1) <= IKFAST_SINCOS_THRESH)
																			continue;
																		j2array[0] = IKatan2(((((-1.00000000000000)*(new_r00)*(sj4))) + (((-1.00000000000000)*(cj4)*(new_r10)))), ((((new_r10)*(sj4))) + (((-1.00000000000000)*(cj4)*(new_r00)))));
																		sj2array[0] = IKsin(j2array[0]);
																		cj2array[0] = IKcos(j2array[0]);
																		if (j2array[0] > IKPI)
																		{
																			j2array[0] -= IK2PI;
																		}
																		else if (j2array[0] < -IKPI)
																		{
																			j2array[0] += IK2PI;
																		}
																		j2valid[0] = true;
																		for (int ij2 = 0; ij2 < 1; ++ij2)
																		{
																			if (!j2valid[ij2])
																			{
																				continue;
																			}
																			_ij2[0] = ij2; _ij2[1] = -1;
																			for (int iij2 = ij2 + 1; iij2 < 1; ++iij2)
																			{
																				if (j2valid[iij2] && IKabs(cj2array[ij2] - cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2] - sj2array[iij2]) < IKFAST_SOLUTION_THRESH)
																				{
																					j2valid[iij2] = false; _ij2[1] = iij2; break;
																				}
																			}
																			j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
																			{
																				IKReal evalcond[4];
																				IKReal x178 = IKcos(j2);
																				IKReal x179 = IKsin(j2);
																				evalcond[0] = ((((cj4)*(new_r10))) + (((new_r00)*(sj4))) + (x179));
																				evalcond[1] = ((((-1.00000000000000)*(x178))) + (((cj4)*(new_r11))) + (((new_r01)*(sj4))));
																				evalcond[2] = ((((cj4)*(new_r00))) + (x178)+(((-1.00000000000000)*(new_r10)*(sj4))));
																				evalcond[3] = ((((cj4)*(new_r01))) + (x179)+(((-1.00000000000000)*(new_r11)*(sj4))));
																				if (IKabs(evalcond[0]) > 0.000001 || IKabs(evalcond[1]) > 0.000001 || IKabs(evalcond[2]) > 0.000001 || IKabs(evalcond[3]) > 0.000001)
																				{
																					continue;
																				}
																			}

																			{
																				vsolutions.push_back(IKSolution()); IKSolution& solution = vsolutions.back();
																				solution.basesol.resize(7);
																				solution.basesol[0].foffset = j0;
																				solution.basesol[0].indices[0] = _ij0[0];
																				solution.basesol[0].indices[1] = _ij0[1];
																				solution.basesol[0].maxsolutions = _nj0;
																				solution.basesol[1].foffset = j1;
																				solution.basesol[1].indices[0] = _ij1[0];
																				solution.basesol[1].indices[1] = _ij1[1];
																				solution.basesol[1].maxsolutions = _nj1;
																				solution.basesol[2].foffset = j2;
																				solution.basesol[2].indices[0] = _ij2[0];
																				solution.basesol[2].indices[1] = _ij2[1];
																				solution.basesol[2].maxsolutions = _nj2;
																				solution.basesol[3].foffset = j3;
																				solution.basesol[3].indices[0] = _ij3[0];
																				solution.basesol[3].indices[1] = _ij3[1];
																				solution.basesol[3].maxsolutions = _nj3;
																				solution.basesol[4].foffset = j4;
																				solution.basesol[4].indices[0] = _ij4[0];
																				solution.basesol[4].indices[1] = _ij4[1];
																				solution.basesol[4].maxsolutions = _nj4;
																				solution.basesol[5].foffset = j5;
																				solution.basesol[5].indices[0] = _ij5[0];
																				solution.basesol[5].indices[1] = _ij5[1];
																				solution.basesol[5].maxsolutions = _nj5;
																				solution.basesol[6].foffset = j6;
																				solution.basesol[6].indices[0] = _ij6[0];
																				solution.basesol[6].indices[1] = _ij6[1];
																				solution.basesol[6].maxsolutions = _nj6;
																				solution.vfree.resize(0);
																			}
																		}
																	}

																}
																else
																{
																	if (1)
																	{
																		continue;

																	}
																	else
																	{
																	}
																}
															}
														}

													}
													else
													{
														{
															IKReal j2array[1], cj2array[1], sj2array[1];
															bool j2valid[1] = { false };
															_nj2 = 1;
															if (IKabs(((-1.00000000000000)*(gconst3)*(new_r21))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.00000000000000)*(gconst3)*(new_r20))) < IKFAST_ATAN2_MAGTHRESH)
																continue;
															j2array[0] = IKatan2(((-1.00000000000000)*(gconst3)*(new_r21)), ((-1.00000000000000)*(gconst3)*(new_r20)));
															sj2array[0] = IKsin(j2array[0]);
															cj2array[0] = IKcos(j2array[0]);
															if (j2array[0] > IKPI)
															{
																j2array[0] -= IK2PI;
															}
															else if (j2array[0] < -IKPI)
															{
																j2array[0] += IK2PI;
															}
															j2valid[0] = true;
															for (int ij2 = 0; ij2 < 1; ++ij2)
															{
																if (!j2valid[ij2])
																{
																	continue;
																}
																_ij2[0] = ij2; _ij2[1] = -1;
																for (int iij2 = ij2 + 1; iij2 < 1; ++iij2)
																{
																	if (j2valid[iij2] && IKabs(cj2array[ij2] - cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2] - sj2array[iij2]) < IKFAST_SOLUTION_THRESH)
																	{
																		j2valid[iij2] = false; _ij2[1] = iij2; break;
																	}
																}
																j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
																{
																	IKReal evalcond[8];
																	IKReal x180 = IKsin(j2);
																	IKReal x181 = IKcos(j2);
																	evalcond[0] = ((((sj3)*(x181))) + (new_r20));
																	evalcond[1] = ((((sj3)*(x180))) + (new_r21));
																	evalcond[2] = ((((cj4)*(new_r10))) + (((new_r00)*(sj4))) + (x180));
																	evalcond[3] = ((((cj4)*(new_r11))) + (((-1.00000000000000)*(x181))) + (((new_r01)*(sj4))));
																	evalcond[4] = ((((cj4)*(new_r00))) + (((-1.00000000000000)*(new_r10)*(sj4))) + (((-1.00000000000000)*(cj3)*(x181))));
																	evalcond[5] = ((((cj4)*(new_r01))) + (((-1.00000000000000)*(new_r11)*(sj4))) + (((-1.00000000000000)*(cj3)*(x180))));
																	evalcond[6] = ((((-1.00000000000000)*(x181))) + (((-1.00000000000000)*(cj3)*(new_r10)*(sj4))) + (((-1.00000000000000)*(new_r20)*(sj3))) + (((cj3)*(cj4)*(new_r00))));
																	evalcond[7] = ((((-1.00000000000000)*(new_r21)*(sj3))) + (((-1.00000000000000)*(x180))) + (((-1.00000000000000)*(cj3)*(new_r11)*(sj4))) + (((cj3)*(cj4)*(new_r01))));
																	if (IKabs(evalcond[0]) > 0.000001 || IKabs(evalcond[1]) > 0.000001 || IKabs(evalcond[2]) > 0.000001 || IKabs(evalcond[3]) > 0.000001 || IKabs(evalcond[4]) > 0.000001 || IKabs(evalcond[5]) > 0.000001 || IKabs(evalcond[6]) > 0.000001 || IKabs(evalcond[7]) > 0.000001)
																	{
																		continue;
																	}
																}

																{
																	vsolutions.push_back(IKSolution()); IKSolution& solution = vsolutions.back();
																	solution.basesol.resize(7);
																	solution.basesol[0].foffset = j0;
																	solution.basesol[0].indices[0] = _ij0[0];
																	solution.basesol[0].indices[1] = _ij0[1];
																	solution.basesol[0].maxsolutions = _nj0;
																	solution.basesol[1].foffset = j1;
																	solution.basesol[1].indices[0] = _ij1[0];
																	solution.basesol[1].indices[1] = _ij1[1];
																	solution.basesol[1].maxsolutions = _nj1;
																	solution.basesol[2].foffset = j2;
																	solution.basesol[2].indices[0] = _ij2[0];
																	solution.basesol[2].indices[1] = _ij2[1];
																	solution.basesol[2].maxsolutions = _nj2;
																	solution.basesol[3].foffset = j3;
																	solution.basesol[3].indices[0] = _ij3[0];
																	solution.basesol[3].indices[1] = _ij3[1];
																	solution.basesol[3].maxsolutions = _nj3;
																	solution.basesol[4].foffset = j4;
																	solution.basesol[4].indices[0] = _ij4[0];
																	solution.basesol[4].indices[1] = _ij4[1];
																	solution.basesol[4].maxsolutions = _nj4;
																	solution.basesol[5].foffset = j5;
																	solution.basesol[5].indices[0] = _ij5[0];
																	solution.basesol[5].indices[1] = _ij5[1];
																	solution.basesol[5].maxsolutions = _nj5;
																	solution.basesol[6].foffset = j6;
																	solution.basesol[6].indices[0] = _ij6[0];
																	solution.basesol[6].indices[1] = _ij6[1];
																	solution.basesol[6].maxsolutions = _nj6;
																	solution.vfree.resize(0);
																}
															}
														}

													}

												}
											}
										}

									}

								}

							}
							else
							{
								{
									IKReal j2array[1], cj2array[1], sj2array[1];
									bool j2valid[1] = { false };
									_nj2 = 1;
									if (IKabs(((-1.00000000000000)*(gconst1)*(new_r21))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.00000000000000)*(gconst1)*(new_r20))) < IKFAST_ATAN2_MAGTHRESH)
										continue;
									j2array[0] = IKatan2(((-1.00000000000000)*(gconst1)*(new_r21)), ((-1.00000000000000)*(gconst1)*(new_r20)));
									sj2array[0] = IKsin(j2array[0]);
									cj2array[0] = IKcos(j2array[0]);
									if (j2array[0] > IKPI)
									{
										j2array[0] -= IK2PI;
									}
									else if (j2array[0] < -IKPI)
									{
										j2array[0] += IK2PI;
									}
									j2valid[0] = true;
									for (int ij2 = 0; ij2 < 1; ++ij2)
									{
										if (!j2valid[ij2])
										{
											continue;
										}
										_ij2[0] = ij2; _ij2[1] = -1;
										for (int iij2 = ij2 + 1; iij2 < 1; ++iij2)
										{
											if (j2valid[iij2] && IKabs(cj2array[ij2] - cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2] - sj2array[iij2]) < IKFAST_SOLUTION_THRESH)
											{
												j2valid[iij2] = false; _ij2[1] = iij2; break;
											}
										}
										j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
										{
											IKReal evalcond[2];
											evalcond[0] = ((((sj3)*(IKcos(j2)))) + (new_r20));
											evalcond[1] = ((((sj3)*(IKsin(j2)))) + (new_r21));
											if (IKabs(evalcond[0]) > 0.000001 || IKabs(evalcond[1]) > 0.000001)
											{
												continue;
											}
										}

										{
											IKReal dummyeval[1];
											IKReal gconst4;
											gconst4 = IKsign(((((-1.00000000000000)*(new_r00)*(new_r12))) + (((new_r02)*(new_r10)))));
											dummyeval[0] = ((((-1.00000000000000)*(new_r00)*(new_r12))) + (((new_r02)*(new_r10))));
											if (IKabs(dummyeval[0]) < 0.0000010000000000)
											{
												continue;

											}
											else
											{
												{
													IKReal j4array[1], cj4array[1], sj4array[1];
													bool j4valid[1] = { false };
													_nj4 = 1;
													if (IKabs(((gconst4)*(new_r12)*(sj2))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.00000000000000)*(gconst4)*(new_r02)*(sj2))) < IKFAST_ATAN2_MAGTHRESH)
														continue;
													j4array[0] = IKatan2(((gconst4)*(new_r12)*(sj2)), ((-1.00000000000000)*(gconst4)*(new_r02)*(sj2)));
													sj4array[0] = IKsin(j4array[0]);
													cj4array[0] = IKcos(j4array[0]);
													if (j4array[0] > IKPI)
													{
														j4array[0] -= IK2PI;
													}
													else if (j4array[0] < -IKPI)
													{
														j4array[0] += IK2PI;
													}
													j4valid[0] = true;
													for (int ij4 = 0; ij4 < 1; ++ij4)
													{
														if (!j4valid[ij4])
														{
															continue;
														}
														_ij4[0] = ij4; _ij4[1] = -1;
														for (int iij4 = ij4 + 1; iij4 < 1; ++iij4)
														{
															if (j4valid[iij4] && IKabs(cj4array[ij4] - cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4] - sj4array[iij4]) < IKFAST_SOLUTION_THRESH)
															{
																j4valid[iij4] = false; _ij4[1] = iij4; break;
															}
														}
														j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
														{
															IKReal evalcond[12];
															IKReal x182 = IKcos(j4);
															IKReal x183 = IKsin(j4);
															evalcond[0] = ((((new_r02)*(x183))) + (((new_r12)*(x182))));
															evalcond[1] = ((((new_r10)*(x182))) + (((new_r00)*(x183))) + (sj2));
															evalcond[2] = ((((new_r11)*(x182))) + (((new_r01)*(x183))) + (((-1.00000000000000)*(cj2))));
															evalcond[3] = ((((new_r02)*(x182))) + (((-1.00000000000000)*(new_r12)*(x183))) + (((-1.00000000000000)*(sj3))));
															evalcond[4] = ((((new_r00)*(x182))) + (((-1.00000000000000)*(cj2)*(cj3))) + (((-1.00000000000000)*(new_r10)*(x183))));
															evalcond[5] = ((((new_r01)*(x182))) + (((-1.00000000000000)*(new_r11)*(x183))) + (((-1.00000000000000)*(cj3)*(sj2))));
															evalcond[6] = ((((-1.00000000000000)*(new_r10)*(sj3)*(x183))) + (((cj3)*(new_r20))) + (((new_r00)*(sj3)*(x182))));
															evalcond[7] = ((((new_r01)*(sj3)*(x182))) + (((cj3)*(new_r21))) + (((-1.00000000000000)*(new_r11)*(sj3)*(x183))));
															evalcond[8] = ((((-1.00000000000000)*(cj3)*(new_r12)*(x183))) + (((cj3)*(new_r02)*(x182))) + (((-1.00000000000000)*(new_r22)*(sj3))));
															evalcond[9] = ((-1.00000000000000) + (((new_r02)*(sj3)*(x182))) + (((cj3)*(new_r22))) + (((-1.00000000000000)*(new_r12)*(sj3)*(x183))));
															evalcond[10] = ((((cj3)*(new_r00)*(x182))) + (((-1.00000000000000)*(cj3)*(new_r10)*(x183))) + (((-1.00000000000000)*(cj2))) + (((-1.00000000000000)*(new_r20)*(sj3))));
															evalcond[11] = ((((-1.00000000000000)*(new_r21)*(sj3))) + (((-1.00000000000000)*(cj3)*(new_r11)*(x183))) + (((cj3)*(new_r01)*(x182))) + (((-1.00000000000000)*(sj2))));
															if (IKabs(evalcond[0]) > 0.000001 || IKabs(evalcond[1]) > 0.000001 || IKabs(evalcond[2]) > 0.000001 || IKabs(evalcond[3]) > 0.000001 || IKabs(evalcond[4]) > 0.000001 || IKabs(evalcond[5]) > 0.000001 || IKabs(evalcond[6]) > 0.000001 || IKabs(evalcond[7]) > 0.000001 || IKabs(evalcond[8]) > 0.000001 || IKabs(evalcond[9]) > 0.000001 || IKabs(evalcond[10]) > 0.000001 || IKabs(evalcond[11]) > 0.000001)
															{
																continue;
															}
														}

														{
															vsolutions.push_back(IKSolution()); IKSolution& solution = vsolutions.back();
															solution.basesol.resize(7);
															solution.basesol[0].foffset = j0;
															solution.basesol[0].indices[0] = _ij0[0];
															solution.basesol[0].indices[1] = _ij0[1];
															solution.basesol[0].maxsolutions = _nj0;
															solution.basesol[1].foffset = j1;
															solution.basesol[1].indices[0] = _ij1[0];
															solution.basesol[1].indices[1] = _ij1[1];
															solution.basesol[1].maxsolutions = _nj1;
															solution.basesol[2].foffset = j2;
															solution.basesol[2].indices[0] = _ij2[0];
															solution.basesol[2].indices[1] = _ij2[1];
															solution.basesol[2].maxsolutions = _nj2;
															solution.basesol[3].foffset = j3;
															solution.basesol[3].indices[0] = _ij3[0];
															solution.basesol[3].indices[1] = _ij3[1];
															solution.basesol[3].maxsolutions = _nj3;
															solution.basesol[4].foffset = j4;
															solution.basesol[4].indices[0] = _ij4[0];
															solution.basesol[4].indices[1] = _ij4[1];
															solution.basesol[4].maxsolutions = _nj4;
															solution.basesol[5].foffset = j5;
															solution.basesol[5].indices[0] = _ij5[0];
															solution.basesol[5].indices[1] = _ij5[1];
															solution.basesol[5].maxsolutions = _nj5;
															solution.basesol[6].foffset = j6;
															solution.basesol[6].indices[0] = _ij6[0];
															solution.basesol[6].indices[1] = _ij6[1];
															solution.basesol[6].maxsolutions = _nj6;
															solution.vfree.resize(0);
														}
													}
												}

											}

										}
									}
								}

							}

						}
					}
				}
			}
		}
	};


	/// solves the inverse kinematics equations.
	/// \param pfree is an array specifying the free joints of the chain.
	IKFAST_API bool ik(const IKReal* eetrans, const IKReal* eerot, const IKReal* pfree, std::vector<IKSolution>& vsolutions) {
		IKSolver solver;
		return solver.ik(eetrans, eerot, pfree, vsolutions);
	}

	IKFAST_API const char* getKinematicsHash() { return "bcb25302dbec7575df10994dd89abd19"; }

	IKFAST_API const char* getIKFastVersion() { return "55"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
	if (argc != 12 + getNumFreeParameters() + 1) {
		printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
			"Returns the ik solutions given the transformation of the end effector specified by\n"
			"a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
			"There are %d free parameters that have to be specified.\n\n", getNumFreeParameters());
		return 1;
	}

	std::vector<IKSolution> vsolutions;
	std::vector<IKReal> vfree(getNumFreeParameters());
	IKReal eerot[9], eetrans[3];
	eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
	eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
	eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
	for (std::size_t i = 0; i < vfree.size(); ++i)
		vfree[i] = atof(argv[13 + i]);
	bool bSuccess = ik(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, vsolutions);

	if (!bSuccess) {
		fprintf(stderr, "Failed to get ik solution\n");
		return -1;
	}

	printf("Found %d ik solutions:\n", (int)vsolutions.size());
	std::vector<IKReal> sol(getNumJoints());
	for (std::size_t i = 0; i < vsolutions.size(); ++i) {
		printf("sol%d (free=%d): ", (int)i, (int)vsolutions[i].GetFree().size());
		std::vector<IKReal> vsolfree(vsolutions[i].GetFree().size());
		vsolutions[i].GetSolution(&sol[0], vsolfree.size() > 0 ? &vsolfree[0] : NULL);
		for (std::size_t j = 0; j < sol.size(); ++j)
			printf("%.15f, ", sol[j]);
		printf("\n");
	}
	return 0;
}

#endif
